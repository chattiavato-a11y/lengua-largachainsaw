<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Chattia</title>
<!-- SHA384(index.html)=22c7f5c18585c37296e7e2e9704550f541a5e444fd37b5ec0bae6773e60e970aae147ef6af6793d48948b5da7fbb9ff4 -->
<meta name="integrity-token" content="">
<!-- **HERE GOES THE RUNTIME INTEGRITY TOKEN (INJECT VIA BUILD/DEPLOY PIPELINE)** -->
<!-- **HERE GOES INTEGRITY GATEWAY** https://withered-mouse-9aee.grabem-holdem-nuts-right.workers.dev -->
<!-- OPS CYSEC CORE | CORS ‚Ä¢ CSP ‚Ä¢ CISA ‚Ä¢ NIST ‚Ä¢ PCI DSS ‚Ä¢ SHA-384 ‚Ä¢ SHA-512 SAFEGUARDS -->

<!-- Patched FontAwesome (CSP + SRI + CORS Safe) -->
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"
  integrity="sha512-RXf+QSDCUqpphKAa+WAc3XQ8fE5H1aO/8e2wY+8Q1n8yVwDh1RZTf1TDN8E+u1n7eU5KyY7X2Qo+hqeZZn+UAQ=="
  data-shared-key="koSTJ_Bhg8aX9lSpSiFi2NwubonelIY_7sGTFrZqa4scqf--UTOnaKSri_UOjJbdckcHnEUMI0U2LHWYnd0De8"
  crossorigin="anonymous" referrerpolicy="no-referrer" />

<style>
/* ---------- COLOR SYSTEM ---------- */
:root{
  --clr-primary:#00c4ff;
  --clr-accent :#ff3bdb;
  --clr-accent-dark:#e000be;
  --clr-bg  :#ffffff;
  --clr-bg-dark:#121212;
  --clr-tx  :#333333;
  --clr-tx-dark:#f0f0f0;
}
body{margin:0;display:flex;align-items:center;justify-content:center;height:100vh;
      font-family:'Segoe UI',Arial,sans-serif;background:var(--clr-bg);color:var(--clr-tx);
      transition:background .3s,color .3s}
body.dark{--clr-bg:var(--clr-bg-dark);--clr-tx:var(--clr-tx-dark)}

/* ---------- CHATBOT ---------- */
#chatbot-container{position:fixed;width:300px;height:540px;background:#251541;border:2px solid var(--clr-accent);
  border-radius:18px;box-shadow:0 8px 32px #0006;display:flex;flex-direction:column;overflow:hidden;
  left:50%;top:50%;transform:translate(-50%,-50%);transition:box-shadow .2s ease;will-change:transform,left,top}
#chatbot-container.dragging{box-shadow:0 12px 36px rgba(0,0,0,.55)}
#chatbot-header{display:flex;justify-content:space-between;align-items:center;gap:.5rem;
  background:linear-gradient(135deg,var(--clr-primary) 0%,var(--clr-accent) 100%);
  color:#fff;font-weight:600;font-size:1.1rem;padding:.75rem 1rem;cursor:grab;user-select:none;
  touch-action:none}
#chatbot-container.dragging #chatbot-header{cursor:grabbing}
#chatbot-header:focus-visible{outline:2px solid var(--clr-primary);outline-offset:4px}
#chatbot-header .ctrl{cursor:pointer;font-size:.75rem;font-weight:500;user-select:none;opacity:.85}
#chatbot-header .ctrl:hover{opacity:1}
#chat-log{flex:1;overflow-y:auto;padding:1rem;background:#1b0e2d;color:#eee;font-size:.94rem}
.chat-msg{margin:.5rem 0;max-width:90%}
.user{margin-left:auto;background:var(--clr-primary);color:#000;padding:.5rem .7rem;border-radius:14px 14px 0 14px}
.bot {margin-right:auto;background:#321b53;color:#fff;padding:.5rem .7rem;border-radius:14px 14px 14px 0}
#chatbot-form-container{background:#220f3a;border-top:1px solid var(--clr-accent);padding:.55rem .7rem}
#chatbot-input-row{display:flex;gap:.6rem}
#chatbot-input{flex:1;background:transparent;border:none;color:#fff;font-size:.95rem;padding:.55rem .6rem}
#chatbot-send{display:flex;align-items:center;justify-content:center;gap:6px;background:var(--clr-accent);border:none;color:#fff;
  font-weight:600;padding:.5rem .9rem;border-radius:8px;cursor:pointer;transition:.3s;box-shadow:0 4px 12px rgba(0,0,0,.25)}
#chatbot-send i{transition:transform .3s;font-size:1rem}
#chatbot-send:hover i{transform:rotate(-45deg)}
#chatbot-send:disabled{background:rgba(255,59,219,.35);color:rgba(255,255,255,.75);cursor:not-allowed;box-shadow:none}
#chatbot-send:focus-visible{outline:2px solid var(--clr-primary);outline-offset:2px}
.turnstile-slot{margin-bottom:.35rem}
.honeypot{position:absolute;left:-10000px;top:auto;width:1px;height:1px;overflow:hidden}
@media(max-width:480px){#chatbot-container{height:75vh;width:90%}}
</style>
</head>
<body>

<!-- ---------- CHATBOT HTML ---------- -->
<div id="chatbot-container" role="dialog" aria-modal="true">
  <div id="chatbot-header" tabindex="0" aria-grabbed="false" aria-label="Chattia chatbot window. Drag or use arrow keys to move.">
    <span id="title" data-en="Chattia" data-es="Chattia">Chattia</span>

    <!-- tiny controls -->
    <div>
      <span id="langCtrl" class="ctrl">ES</span>
      &nbsp;|&nbsp;
      <span id="themeCtrl" class="ctrl">Dark</span>
    </div>
  </div>

  <div id="chat-log" aria-live="polite"></div>

  <div id="chatbot-form-container">
    <form id="chatbot-input-row" autocomplete="off">
      <div id="turnstile-slot" class="turnstile-slot" aria-hidden="true"></div>
      <input id="turnstile-token" type="hidden" name="cf-turnstile-token" value="" data-require="false">
      <label class="honeypot" for="chatbot-company">Company</label>
      <input id="chatbot-company" class="honeypot" type="text" name="company" tabindex="-1" autocomplete="off" aria-hidden="true">
      <input id="chatbot-input" type="text" placeholder="Type your message... [Enter for input]" required maxlength="256"
             data-en-ph="Type your message... [Enter for input]" data-es-ph="Escriba su mensaje... [Intro para enviar]">
      <button id="chatbot-send" type="submit" disabled aria-label="Send">
        <i class="fa fa-arrow-right" aria-hidden="true"></i>
      </button>
    </form>
  </div>
</div>

<!-- ---------- SPEECH-TO-TEXT CONTROLS ---------- -->
<div id="stt-controls" style="padding:.6rem;background:#1b0e2d;color:#ddd;border-top:1px solid #4a2a7a;margin-top:.5rem">
  <div style="font-size:.8rem;margin-bottom:.35rem;line-height:1.4">
    <strong>Voice Bridge</strong> ‚Üí Tap the microphone to capture audio, auto-sanitize it, and deliver it straight to the chatbot.
  </div>
  <div style="display:flex;gap:.75rem;align-items:center;flex-wrap:wrap">
    <button id="mic-btn" type="button" style="padding:.45rem .8rem;border-radius:.6rem;border:1px solid #5b3c8d;background:#2d1849;color:#fff;cursor:pointer">
      üéô Record
    </button>
    <span id="stt-status" aria-live="polite" style="font-size:.78rem;color:#cfc7ff">Idle ‚Äî ready to listen.</span>
  </div>
</div>

<!-- ---------- CHATBOT LOGIC ---------- -->
<script>
const qs=s=>document.querySelector(s),
      qsa=s=>[...document.querySelectorAll(s)];

const state={
  conversation:[],
  isSending:false
};

const integrityMeta = document.querySelector('meta[name="integrity-token"]');
const INTEGRITY_HEADER = 'X-Integrity';
const INTEGRITY_TOKEN = integrityMeta?.content?.trim() || '';
const INTEGRITY_GATEWAY = 'https://withered-mouse-9aee.grabem-holdem-nuts-right.workers.dev';
// **HERE GOES INTEGRITY HEADER VALUE (MUST MATCH WORKER POLICY)**
// **HERE GOES PROTECTED INTEGRITY GATEWAY URL** (OPS CYSEC CORE COMPLIANT)
const INTEGRITY_PROTOCOLS = 'CORS,CSP,OPS-CySec-Core,CISA,NIST,PCI-DSS,SHA-384,SHA-512';
const sharedIntegrityHeaders = Object.freeze({
  [INTEGRITY_HEADER]: INTEGRITY_TOKEN,
  'X-Integrity-Gateway': INTEGRITY_GATEWAY,
  'X-Integrity-Protocols': INTEGRITY_PROTOCOLS
});

/* ===== API base routing (GitHub Pages ‚Üí workers.dev) ===== */
const UI_ORIGIN = location.origin;
const API_BASE = (UI_ORIGIN === 'https://chattiavato-a11y.github.io')
  ? 'https://ops-chattia-api.grabem-holdem-nuts-right.workers.dev'
  : '';
// **HERE GOES PRODUCTION WORKER BASE URL UNDER INTEGRITY CONTROLS**
const CHAT_PATH = '/api/chat';
const STT_PATH = '/api/stt';
const CHAT_URL = `${API_BASE}${CHAT_PATH}`; // **HERE GOES PROTECTED CHAT ENDPOINT**
const STT_URL = `${API_BASE}${STT_PATH}`;   // **HERE GOES PROTECTED STT ENDPOINT**
const AUTH_URL = `${API_BASE}/auth/issue`;  // **HERE GOES SIGNATURE MINTING ROUTE**

/* ===== Integrity helpers (browser) ===== */
function randNonceHex(len = 16){
  const u8 = new Uint8Array(len);
  crypto.getRandomValues(u8);
  return [...u8].map(b => b.toString(16).padStart(2,'0')).join('');
}

async function sha256HexOfString(value){
  const buf = new TextEncoder().encode(value);
  const digest = await crypto.subtle.digest('SHA-256', buf);
  return [...new Uint8Array(digest)].map(b => b.toString(16).padStart(2,'0')).join('');
}

async function signedPost(path, bodyObj){
  const ts = String(Math.floor(Date.now()/1000));
  const nonce = randNonceHex(16);
  const body = JSON.stringify(bodyObj);
  const body_sha256 = await sha256HexOfString(body);

  const mintResponse = await fetch(AUTH_URL, {
    method:'POST',
    headers:{
      ...sharedIntegrityHeaders,
      'Content-Type':'application/json'
    },
    body: JSON.stringify({ ts, nonce, method:'POST', path, body_sha256 })
  });

  if(!mintResponse.ok) throw new Error('mint_failed');
  const { signature } = await mintResponse.json();
  if(!signature) throw new Error('signature_missing');

  return fetch(`${API_BASE}${path}`, {
    method:'POST',
    headers:{
      ...sharedIntegrityHeaders,
      'Content-Type':'application/json',
      'X-OPS-Timestamp': ts,
      'X-OPS-Nonce': nonce,
      'X-OPS-Signature': signature
    },
    body
  });
}

/* === Language toggle === */
const langCtrl   = qs('#langCtrl'),
      transNodes = qsa('[data-en]'),
      phNodes    = qsa('[data-en-ph]');

langCtrl.onclick = () => {
  const toES = langCtrl.textContent === 'ES';      // going EN‚ÜíES ?
  document.documentElement.lang = toES ? 'es' : 'en';
  langCtrl.textContent = toES ? 'EN' : 'ES';

  // text nodes
  transNodes.forEach(node => node.textContent = toES ? node.dataset.es : node.dataset.en);

  // placeholders
  phNodes.forEach(node => node.placeholder  = toES ? node.dataset.esPh : node.dataset.enPh);
};

/* === Theme toggle === */
const themeCtrl = qs('#themeCtrl');
themeCtrl.onclick = () => {
  const dark = themeCtrl.textContent === 'Dark';
  document.body.classList.toggle('dark', dark);
  themeCtrl.textContent = dark ? 'Light' : 'Dark';
};

/* === Chatbot core === */
const container = qs('#chatbot-container'),
      header = qs('#chatbot-header'),
      log   = qs('#chat-log'),
      form  = qs('#chatbot-input-row'),
      input = qs('#chatbot-input'),
      send  = qs('#chatbot-send'),
      honeypot = qs('#chatbot-company'),
      turnstileToken = qs('#turnstile-token');

const micBtn = qs('#mic-btn');
const sttStatus = qs('#stt-status');

const isTurnstileRequired = () => Boolean(turnstileToken && turnstileToken.dataset.require === 'true');

const sessionGuard = {
  warnings:0,
  sessionTerminated:false,
  inactivityTimer:null
};

const WARNING_MESSAGE = 'Apologies, but I cannot execute that request, do you have any questions about our website?';
const TERMINATE_MESSAGE = 'Apologies, but I must not continue with this chat and I must end this session.';
const TIMEOUT_MESSAGE = 'Thank you for visiting us, we look forward to you visiting us once more, Enjoy your day!';

function disableInputs(){
  input.disabled = true;
  send.disabled = true;
  micBtn?.setAttribute('disabled','');
}

function resetInactivityTimer(){
  if(sessionGuard.sessionTerminated) return;
  if(sessionGuard.inactivityTimer) clearTimeout(sessionGuard.inactivityTimer);
  sessionGuard.inactivityTimer = setTimeout(()=>{
    terminateSession(TIMEOUT_MESSAGE,{ clearLog:true, clearConversation:true, status:'Session closed after inactivity.' });
  },60000);
}

function terminateSession(message,{clearLog=false, clearConversation=false, status='Session closed.'}={}){
  if(sessionGuard.sessionTerminated) return;
  sessionGuard.sessionTerminated = true;
  if(sessionGuard.inactivityTimer){
    clearTimeout(sessionGuard.inactivityTimer);
    sessionGuard.inactivityTimer = null;
  }
  if(clearConversation) state.conversation = [];
  if(clearLog) log.innerHTML = '';
  disableInputs();
  state.isSending = false;
  forceStopRecording();
  updateSendState();
  if(sttStatus) sttStatus.textContent = status;
  addMsg(message,'bot');
}

function updateSendState(){
  const hasText = Boolean(input.value.trim());
  const botSuspect = honeypot && honeypot.value.trim().length>0;
  const turnstileReady = !isTurnstileRequired() || (turnstileToken && turnstileToken.value.trim().length>0);
  send.disabled = sessionGuard.sessionTerminated || !hasText || state.isSending || botSuspect || !turnstileReady;
}

input.addEventListener('input', updateSendState);
honeypot && honeypot.addEventListener('input', updateSendState);

function addMsg(txt,cls){
  const div = document.createElement('div');
  div.className = 'chat-msg '+cls;
  div.textContent = txt;
  log.appendChild(div);
  log.scrollTop = log.scrollHeight;
  resetInactivityTimer();
  return div;
}

const MALICIOUS_PATTERNS = [
  /<[^>]*>/i,
  /script/i,
  /malicious/i,
  /attack/i,
  /prompt/i,
  /ignore/i,
  /hack/i,
  /drop\s+table/i
];

const WEBSITE_KEYWORDS = [
  'website','site','chattia','product','service','support','order','account','pricing','contact','help'
];

function sanitizeInput(text=''){
  return text.replace(/[<>]/g,'').replace(/\s+/g,' ').trim();
}

function violatesPolicy(text){
  const lower = text.toLowerCase();
  const looksMalicious = MALICIOUS_PATTERNS.some(rx => rx.test(lower));
  const onTopic = WEBSITE_KEYWORDS.some(word => lower.includes(word));
  return looksMalicious || !onTopic;
}

function enforcePolicy(){
  sessionGuard.warnings += 1;
  if(sessionGuard.warnings >= 2){
    terminateSession(TERMINATE_MESSAGE,{ status:'Session closed for security.' });
    return;
  }
  addMsg(WARNING_MESSAGE,'bot');
  if(sttStatus) sttStatus.textContent = 'Awaiting an on-topic website question.';
}

async function sendToChatbot(locale, origin){
  state.isSending = true;
  updateSendState();

  const typingEl = addMsg('‚Ä¶','bot');
  typingEl.setAttribute('aria-live','assertive');

  try{
    const response = await signedPost(CHAT_PATH, {
      messages: state.conversation,
      metadata: { channel:'chattia-web', locale, input_origin:origin }
    });

    if(!response.ok) throw new Error('Network response was not ok');
    const d = await response.json();
    const reply = (d.reply || 'No reply.').trim();
    typingEl.textContent = reply;
    state.conversation.push({role:'assistant',content:reply});
  }catch(err){
    console.error(err);
    typingEl.textContent = 'Error: Can‚Äôt reach Chattia.';
  }finally{
    state.isSending = false;
    updateSendState();
  }
}

function processUserMessage(rawText, origin){
  if(sessionGuard.sessionTerminated) return;
  const sanitized = sanitizeInput(rawText);
  if(!sanitized) return;

  addMsg(sanitized,'user');

  if(violatesPolicy(sanitized)){
    enforcePolicy();
    input.value='';
    updateSendState();
    return;
  }

  const locale = document.documentElement.lang || 'en';
  state.conversation.push({role:'user',content:sanitized});
  input.value='';
  updateSendState();
  sendToChatbot(locale, origin);
}

form.addEventListener('submit', e => {
  e.preventDefault();
  if(sessionGuard.sessionTerminated) return;
  if(honeypot && honeypot.value.trim().length>0) return;
  if(isTurnstileRequired() && turnstileToken && !turnstileToken.value.trim()) return;

  const msg = input.value.trim();
  if(!msg) return;
  processUserMessage(msg,'text');
});

updateSendState();

/* === Draggable window === */
const dragState = {
  active:false,
  offsetX:0,
  offsetY:0,
  position:null,
  userInitiated:false
};

const VIEWPORT_MARGIN = 16;

function clampPosition(x,y){
  const width = container.offsetWidth;
  const height = container.offsetHeight;
  const maxX = Math.max(VIEWPORT_MARGIN, window.innerWidth - width - VIEWPORT_MARGIN);
  const maxY = Math.max(VIEWPORT_MARGIN, window.innerHeight - height - VIEWPORT_MARGIN);
  const clampedX = Math.min(Math.max(x, VIEWPORT_MARGIN), maxX);
  const clampedY = Math.min(Math.max(y, VIEWPORT_MARGIN), maxY);
  return {x:clampedX, y:clampedY};
}

function applyPosition(x,y){
  const {x:clampedX, y:clampedY} = clampPosition(x,y);
  container.style.transform = 'none';
  container.style.left = `${clampedX}px`;
  container.style.top = `${clampedY}px`;
  dragState.position = {x:clampedX, y:clampedY};
}

function centerContainer(){
  const width = container.offsetWidth;
  const height = container.offsetHeight;
  const centeredX = (window.innerWidth - width) / 2;
  const centeredY = (window.innerHeight - height) / 2;
  applyPosition(centeredX, centeredY);
  dragState.userInitiated = false;
}

function startDrag(event){
  if(event.button !== undefined && event.button !== 0) return;
  if(event.target.closest('.ctrl')) return;
  dragState.active = true;
  const rect = container.getBoundingClientRect();
  dragState.offsetX = event.clientX - rect.left;
  dragState.offsetY = event.clientY - rect.top;
  dragState.userInitiated = true;
  container.classList.add('dragging');
  header.setPointerCapture?.(event.pointerId);
  header.setAttribute('aria-grabbed','true');
  event.preventDefault();
}

function onDrag(event){
  if(!dragState.active) return;
  const x = event.clientX - dragState.offsetX;
  const y = event.clientY - dragState.offsetY;
  applyPosition(x, y);
}

function endDrag(event){
  if(!dragState.active) return;
  dragState.active = false;
  container.classList.remove('dragging');
  header.releasePointerCapture?.(event.pointerId);
  header.setAttribute('aria-grabbed','false');
}

function maintainBounds(){
  if(!dragState.position){
    centerContainer();
    return;
  }
  applyPosition(dragState.position.x, dragState.position.y);
}

header.addEventListener('pointerdown', startDrag);
window.addEventListener('pointermove', onDrag);
window.addEventListener('pointerup', endDrag);
window.addEventListener('pointercancel', endDrag);
window.addEventListener('resize', () => {
  if(dragState.userInitiated){
    maintainBounds();
  }else{
    centerContainer();
  }
});

header.addEventListener('keydown', event => {
  const step = event.shiftKey ? 32 : 16;
  let newX = dragState.position?.x ?? container.offsetLeft;
  let newY = dragState.position?.y ?? container.offsetTop;
  let moved = false;
  switch(event.key){
    case 'ArrowUp':
      newY -= step;
      moved = true;
      break;
    case 'ArrowDown':
      newY += step;
      moved = true;
      break;
    case 'ArrowLeft':
      newX -= step;
      moved = true;
      break;
    case 'ArrowRight':
      newX += step;
      moved = true;
      break;
    case 'Home':
      event.preventDefault();
      centerContainer();
      dragState.userInitiated = false;
      return;
    default:
      break;
  }
  if(moved){
    event.preventDefault();
    applyPosition(newX, newY);
    dragState.userInitiated = true;
  }
});

centerContainer();

window.chattiaTurnstile = {
  setToken(token=''){
    if(!turnstileToken) return;
    turnstileToken.value = token;
    updateSendState();
  },
  clear(){
    if(!turnstileToken) return;
    turnstileToken.value = '';
    updateSendState();
  },
  require(flag=true){
    if(!turnstileToken) return;
    turnstileToken.dataset.require = flag ? 'true' : 'false';
    updateSendState();
  }
};

const mo = { mimeType: 'audio/webm' }; // compact and widely supported
let mediaStream, mediaRecorder, audioChunks = [], recording = false;

function stopMediaTracks(){
  mediaStream?.getTracks().forEach(t=>t.stop());
  mediaStream = undefined;
}

async function handleRecordingStop(){
  stopMediaTracks();
  const blob = new Blob(audioChunks, { type: mo.mimeType || 'audio/webm' });
  audioChunks = [];

  if(blob.size === 0){
    if(sttStatus) sttStatus.textContent = 'No audio captured.';
    return;
  }
  if(blob.size > 8_000_000){
    if(sttStatus) sttStatus.textContent = 'Audio too large; please record a shorter clip.';
    return;
  }

  const form = new FormData();
  form.append('audio', blob, 'clip.webm');
  form.append('lang', document.documentElement.lang || 'en');
  form.append('prefer','');

  try{
    if(sttStatus) sttStatus.textContent = 'Transcribing securely‚Ä¶';
    const resp = await fetch(STT_URL,{
      method:'POST',
      headers: sharedIntegrityHeaders,
      body:form
    });
    const data = await resp.json();
    if(resp.ok && data.text){
      if(sttStatus) sttStatus.textContent = 'Transcript received and sanitized.';
      processUserMessage(data.text,'voice');
    }else{
      if(sttStatus) sttStatus.textContent = 'Unable to transcribe audio.';
    }
  }catch(err){
    console.error(err);
    if(sttStatus) sttStatus.textContent = 'Network error while reaching STT service.';
  }
}

micBtn?.addEventListener('click', async () => {
  if(sessionGuard.sessionTerminated) return;

  if(!recording){
    try{
      audioChunks = [];
      mediaStream = await navigator.mediaDevices.getUserMedia({ audio:true });
      mediaRecorder = new MediaRecorder(mediaStream, mo);
      mediaRecorder.ondataavailable = e => { if(e.data && e.data.size) audioChunks.push(e.data); };
      mediaRecorder.onstop = handleRecordingStop;
      mediaRecorder.start();
      recording = true;
      micBtn.textContent = '‚èπ Stop';
      if(sttStatus) sttStatus.textContent = 'Recording‚Ä¶ release to process.';
      resetInactivityTimer();
    }catch(err){
      console.error(err);
      if(sttStatus) sttStatus.textContent = 'Microphone permission denied.';
      stopMediaTracks();
    }
    return;
  }

  recording = false;
  micBtn.textContent = 'üéô Record';
  if(sttStatus) sttStatus.textContent = 'Processing audio‚Ä¶';
  mediaRecorder?.stop();
});

function forceStopRecording(){
  if(recording){
    recording = false;
    mediaRecorder?.stop();
  }
  micBtn?.setAttribute('disabled','');
  stopMediaTracks();
}

window.addEventListener('beforeunload', forceStopRecording);

resetInactivityTimer();
</script>
</body>
</html>
