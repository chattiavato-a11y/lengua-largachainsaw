<!-- index.html — GitHub Pages UI (auth → signed chat; hidden STT panel wired) -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>Chattia</title>
<meta name="integrity-token" content="https://chattiavato-a11y.github.io">
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"
  integrity="sha512-RXf+QSDCUqpphKAa+WAc3XQ8fE5H1aO/8e2wY+8Q1n8yVwDh1RZTf1TDN8E+u1n7eU5KyY7X2Qo+hqeZZn+UAQ=="
  crossorigin="anonymous" referrerpolicy="no-referrer" />
<style>
:root{
  --clr-primary:#00c4ff;
  --clr-accent:#ff3bdb;
  --body-bg:#f4f2ff;
  --body-text:#1d1232;
  --surface:#251541;
  --surface-soft:#220f3a;
  --surface-alt:#1b0e2d;
  --bot-bg:#321b53;
  --bot-text:#fff;
  --user-text:#050118;
  --control-bg:rgba(255,255,255,0.08);
}
@media (prefers-color-scheme:dark){
  :root{
    --body-bg:#050111;
    --body-text:#f4f3ff;
  }
}
body[data-theme="light"]{
  --body-bg:#fdfbff;
  --body-text:#1b1030;
  --surface:#faf6ff;
  --surface-alt:#f5edff;
  --surface-soft:#ece0ff;
  --bot-bg:#efe7ff;
  --bot-text:#2d1650;
  --control-bg:rgba(10,4,32,0.08);
}
body{
  margin:0;
  min-height:100vh;
  font-family:system-ui,Segoe UI,Arial,sans-serif;
  background:var(--body-bg);
  color:var(--body-text);
  transition:background .3s ease,color .3s ease;
  padding:env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
}
#chatbot-container{
  position:fixed;
  right:clamp(16px,4vw,32px);
  bottom:clamp(16px,4vh,32px);
  width:min(360px,calc(100vw - 32px));
  height:min(560px,calc(100vh - 32px));
  background:var(--surface);
  border:2px solid var(--clr-accent);
  border-radius:20px;
  box-shadow:0 20px 50px rgba(5,1,17,.45);
  display:flex;
  flex-direction:column;
  overflow:hidden;
  z-index:10;
  backdrop-filter:blur(4px);
}
@supports (height:100dvh){
  #chatbot-container{height:min(560px,calc(100dvh - 32px));}
}
#chatbot-header{
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:.85rem 1.1rem;
  gap:.75rem;
  background:linear-gradient(135deg,var(--clr-primary),var(--clr-accent));
  color:#fff;
  font-weight:600;
}
#chatbot-header h1{
  font-size:1.05rem;
  margin:0;
}
.ctrl-btn{
  background:rgba(255,255,255,.18);
  border:none;
  border-radius:999px;
  color:#fff;
  font-size:.82rem;
  font-weight:600;
  padding:.25rem .85rem;
  cursor:pointer;
}
.ctrl-btn:focus-visible{outline:2px solid #fff;outline-offset:2px;}
#chat-log{
  flex:1;
  overflow:auto;
  padding:1rem;
  background:var(--surface-alt);
  color:var(--bot-text);
  font-size:.95rem;
}
.chat-msg{
  margin:.5rem 0;
  max-width:90%;
  line-height:1.35;
}
.user{
  margin-left:auto;
  background:var(--clr-primary);
  color:var(--user-text);
  padding:.5rem .7rem;
  border-radius:16px 16px 0 16px;
}
.bot{
  margin-right:auto;
  background:var(--bot-bg);
  color:var(--bot-text);
  padding:.5rem .7rem;
  border-radius:16px 16px 16px 0;
}
#chatbot-form-container{
  background:var(--surface-soft);
  border-top:1px solid rgba(255,255,255,.12);
  padding:.65rem .9rem calc(.65rem + env(safe-area-inset-bottom));
}
#chatbot-input-row{
  display:flex;
  gap:.6rem;
}
#chatbot-input{
  flex:1;
  background:var(--control-bg);
  border:none;
  border-radius:12px;
  color:var(--bot-text);
  font-size:.95rem;
  padding:.6rem .75rem;
}
#chatbot-input::placeholder{color:rgba(255,255,255,.75);}
body[data-theme="light"] #chatbot-input::placeholder{color:#6b5d84;}
#chatbot-send{
  display:flex;
  align-items:center;
  justify-content:center;
  gap:6px;
  background:var(--clr-accent);
  border:none;
  color:#fff;
  font-weight:600;
  padding:.55rem .95rem;
  border-radius:12px;
  cursor:pointer;
  box-shadow:0 6px 16px rgba(255,59,219,.35);
}
.visually-hidden{position:absolute!important;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0 0 0 0);white-space:nowrap;border:0;}
#chatbot-send i{font-size:.9rem;}
.turnstile-slot{height:0;overflow:hidden}
#stt-controls{display:none}
@media (max-width:720px){
  #chatbot-container{
    width:min(420px,calc(100vw - 24px));
    right:16px;
    left:16px;
    margin:0 auto;
  }
}
@media (max-width:560px){
  #chatbot-container{
    inset:0;
    width:100vw;
    height:100vh;
    border-radius:0;
    margin:0;
    transform:none;
  }
  @supports (height:100dvh){
    #chatbot-container{height:100dvh;}
  }
  #chatbot-header{padding:calc(.85rem + env(safe-area-inset-top)) 1rem .85rem;}
  #chatbot-form-container{padding:.65rem 1rem calc(.65rem + env(safe-area-inset-bottom));}
}
@media (max-height:520px){
  #chatbot-container{height:calc(100vh - 24px);}
  #chatbot-header{padding:.65rem .9rem;}
  #chatbot-form-container{padding:.5rem .75rem;}
}
@media (max-width:380px){
  #chatbot-header h1{font-size:.95rem;}
  #chatbot-send{padding:.5rem .75rem;}
}
@media (prefers-reduced-motion:reduce){
  *,*::before,*::after{transition:none!important;animation-duration:.001s!important;}
}
</style>
</head>
<body>

<div id="chatbot-container" role="dialog" aria-modal="true">
  <div id="chatbot-header">
    <h1>Chattia</h1>
    <button id="themeCtrl" class="ctrl-btn" type="button" aria-pressed="false">Dark</button>
  </div>
  <div id="chat-log" aria-live="polite"></div>
  <div id="chatbot-form-container">
    <form id="chatbot-input-row" autocomplete="off">
      <div id="turnstile-slot" class="turnstile-slot" aria-hidden="true"></div>
      <input id="turnstile-token" type="hidden" name="cf-turnstile-response" value="" data-require="true">
      <label class="visually-hidden" for="chatbot-company">Company</label>
      <input id="chatbot-company" type="text" name="company" autocomplete="off" aria-hidden="true" tabindex="-1" style="position:absolute;left:-9999px">
      <input id="chatbot-input" type="text" placeholder="Type your message… [Enter]" maxlength="256">
      <button id="chatbot-send" type="submit" aria-label="Send"><i class="fa fa-arrow-right"></i></button>
    </form>
  </div>
</div>

<script src="services/fallback_kb.js"></script>
<script>
/* ------------------- CONFIG (match Worker) ------------------- */
const INTEGRITY_VALUE   = (document.querySelector('meta[name="integrity-token"]')?.content||'').trim() || 'https://chattiavato-a11y.github.io';
const INTEGRITY_GATEWAY = 'https://withered-mouse-9aee.grabem-holdem-nuts-right.workers.dev';
const INTEGRITY_PROTOCOLS = 'CORS,CSP,OPS-CySec-Core,CISA,NIST,PCI-DSS,SHA-384,SHA-512';

const API_BASE = 'https://withered-mouse-9aee.grabem-holdem-nuts-right.workers.dev';
const CHAT_PATH = '/api/chat';
const STT_PATH  = '/api/stt';
const AUTH_URL  = `${API_BASE}/auth/issue`;

const TURNSTILE_SITE_KEY = '0x4AAAAAACBDyXYbdQg180H4';

const sharedIntegrityHeaders = Object.freeze({
  'X-Integrity': INTEGRITY_VALUE,
  'X-Integrity-Gateway': INTEGRITY_GATEWAY,
  'X-Integrity-Protocols': INTEGRITY_PROTOCOLS
});
const TURNSTILE_SITE_KEY = '0x4AAAAAACBDyXYbdQg180H4';
const ESCALATION_URL = `${INTEGRITY_GATEWAY.replace(/\/$/, '')}/fallback/escalate`;
const CONFIDENCE_THRESHOLD = 0.55;
const MEMORY_KEY = 'chattia.memory.v1';
const MEMORY_WINDOW = 40;

/* ------------------- UI refs ------------------- */
const logEl  = document.querySelector('#chat-log');
const form   = document.querySelector('#chatbot-input-row');
const input  = document.querySelector('#chatbot-input');
const send   = document.querySelector('#chatbot-send');
const honeyp = document.querySelector('#chatbot-company');
const tSlot  = document.querySelector('#turnstile-slot');
const tTok   = document.querySelector('#turnstile-token');
const themeCtrl = document.querySelector('#themeCtrl');

const state = { conversation:[], isSending:false };
const session = { terminated:false };

/* ------------------- Theme + viewport ergonomics ------------------- */
const THEME_KEY = 'chattia-theme';
const prefersDark = window.matchMedia ? window.matchMedia('(prefers-color-scheme: dark)') : {
  matches:true,
  addEventListener:()=>{},
  addListener:()=>{}
};

function readStoredTheme(){ try { return localStorage.getItem(THEME_KEY); } catch { return null; } }
function storeTheme(theme){ try { localStorage.setItem(THEME_KEY, theme); } catch { /* ignore */ } }

function applyTheme(theme){
  document.body.dataset.theme = theme;
  if (themeCtrl){
    const nextLabel = theme === 'dark' ? 'Light' : 'Dark';
    themeCtrl.textContent = nextLabel;
    themeCtrl.setAttribute('aria-pressed', theme === 'dark' ? 'true' : 'false');
  }
}

const initialTheme = readStoredTheme() || (prefersDark.matches ? 'dark' : 'light');
applyTheme(initialTheme);

themeCtrl?.addEventListener('click', ()=>{
  const next = document.body.dataset.theme === 'light' ? 'dark' : 'light';
  applyTheme(next);
  storeTheme(next);
});

function currentLang(){
  const lng = (document.documentElement.lang || 'en').toLowerCase();
  return lng.startsWith('es') ? 'es' : 'en';
}
function fallbackReply(userText){
  try {
    if (window.FallbackKB?.reply) {
      return window.FallbackKB.reply(userText || '', currentLang());
    }
  } catch {}
  return currentLang()==='es'
    ? 'Estoy fuera de línea, pero puedo contarte sobre OPS Remote Professional Network.'
    : 'I’m offline but can still summarize the OPS Remote Professional Network.';
}
function validMemoryEntry(entry){
  return entry && typeof entry === 'object' && typeof entry.role === 'string' && typeof entry.content === 'string';
}
function loadMemory(){
  try {
    const raw = localStorage.getItem(MEMORY_KEY);
    if (!raw) return [];
    const parsed = JSON.parse(raw);
    if (!Array.isArray(parsed)) return [];
    return parsed.filter(validMemoryEntry).slice(-MEMORY_WINDOW);
  } catch {
    return [];
  }
}
function persistMemory(){
  try {
    localStorage.setItem(MEMORY_KEY, JSON.stringify(state.conversation.slice(-MEMORY_WINDOW)));
  } catch {}
}
function recordMessage(role, content, meta = {}){
  state.conversation.push({ role, content, meta, ts: Date.now() });
  if (state.conversation.length > MEMORY_WINDOW) {
    state.conversation = state.conversation.slice(-MEMORY_WINDOW);
  }
  persistMemory();
}
function replayHistory(history){
  history.forEach(msg => addMsg(msg.content, msg.role === 'user' ? 'user' : 'bot'));
}
function bootstrapConversation(){
  const history = loadMemory();
  if (history.length){
    state.conversation = history;
    replayHistory(history);
    return;
  }
  const greeting = fallbackReply('');
  addMsg(greeting,'bot');
  recordMessage('assistant', greeting, { source:'fallback', reason:'greeting' });
}
function notifyEscalation(details = {}){
  const payload = { ...details, lang: currentLang(), conversationTail: state.conversation.slice(-6) };
  try {
    fetch(ESCALATION_URL, {
      method:'POST',
      headers:{ ...sharedIntegrityHeaders, 'Content-Type':'application/json' },
      body: JSON.stringify({ ...payload, timestamp: new Date().toISOString() })
    }).catch(()=>{});
  } catch {}
}
function escalateWithFallback(reason, userText, thinkingEl, extra = {}){
  const fallback = fallbackReply(userText);
  thinkingEl.textContent = fallback;
  recordMessage('assistant', fallback, { source:'fallback', reason, ...extra });
  notifyEscalation({ reason, userText, fallback, ...extra });
}

function sanitizedMessages(){
  return state.conversation.map(item => ({ role: item.role, content: item.content }));
}

function recentSanitized(count){
  const slice = state.conversation.slice(-count);
  return slice.map(item => ({ role: item.role, content: item.content }));
}

bootstrapConversation();
updateSend();

function hexNonce32(){ const u8 = crypto.getRandomValues(new Uint8Array(16)); return [...u8].map(b=>b.toString(16).padStart(2,'0')).join(''); }
async function sha256Hex(input){ const enc = typeof input==='string'? new TextEncoder().encode(input): input; const view = enc instanceof Uint8Array? enc: new Uint8Array(enc); const d = await crypto.subtle.digest('SHA-256', view); return [...new Uint8Array(d)].map(b=>b.toString(16).padStart(2,'0')).join(''); }

/* ------------------- Integrity signing (browser) ------------------- */
function hexNonce32(){ const u8=crypto.getRandomValues(new Uint8Array(16)); return [...u8].map(b=>b.toString(16).padStart(2,'0')).join(''); }
async function sha256Hex(input){
  const enc = typeof input==='string' ? new TextEncoder().encode(input) : (input instanceof Uint8Array ? input : new Uint8Array(input));
  const d = await crypto.subtle.digest('SHA-256', enc);
  return [...new Uint8Array(d)].map(b=>b.toString(16).padStart(2,'0')).join('');
}
async function mintSignature(path, method, bodySha){
  const ts = Math.floor(Date.now()/1000);
  const nonce = hexNonce32();
  const payload = { ts, nonce, method, path, body_sha256: bodySha };
  const r = await fetch(AUTH_URL, { method:'POST', headers:{...sharedIntegrityHeaders,'Content-Type':'application/json'}, body:JSON.stringify(payload) });
  if (!r.ok) throw new Error('auth_issue_failed');
  const j = await r.json();
  if (!j?.signature) throw new Error('signature_missing');
  return { signature:j.signature, ts:String(ts), nonce };
}
async function signedPost(path, json){
  const body = JSON.stringify(json);
  const bodySha = await sha256Hex(body);
  const {signature, ts, nonce} = await mintSignature(path, 'POST', bodySha);
  return fetch(`${API_BASE}${path}`, {
    method:'POST',
    headers:{ ...sharedIntegrityHeaders, 'Content-Type':'application/json','X-Request-Signature':signature,'X-Request-Timestamp':ts,'X-Request-Nonce':nonce },
    body
  });
}
async function signedFormPost(path, form){
  const probe = new Request('https://example.invalid',{method:'POST',body:form});
  const buf = await probe.arrayBuffer();
  const ct  = probe.headers.get('content-type') || 'application/octet-stream';
  const bodySha = await sha256Hex(buf);
  const {signature, ts, nonce} = await mintSignature(path, 'POST', bodySha);
  return fetch(`${API_BASE}${path}`, {
    method:'POST',
    headers:{ ...sharedIntegrityHeaders, 'Content-Type':ct, 'X-Request-Signature':signature,'X-Request-Timestamp':ts,'X-Request-Nonce':nonce },
    body: buf
  });
}

/* ------------------- Chat flow ------------------- */
form.addEventListener('submit', async (e)=>{
  e.preventDefault();
  if (session.terminated) return;
  if (honeyp?.value.trim()) return; // honeypot
  if (tTok.dataset.require==='true' || !tTok.value.trim()) return;

  addMsg(msg,'user');
  recordMessage('user', msg, { source:'web' });
  input.value=''; updateSend();

  state.conversation.push({role:'user',content:msg});
  const typing = addMsg('…','bot');

  try{
    const sanitized = sanitizedMessages();
    const trainingWindow = recentSanitized(6);
    const payload = {
      messages: sanitized,
      training_memory: trainingWindow,
      metadata:{
        channel:'chattia-web',
        locale: currentLang(),
        memory_key: MEMORY_KEY,
        memory_window: state.conversation.length,
        confidence_threshold: CONFIDENCE_THRESHOLD
      }
    };
    const turnToken = turnstileToken?.value?.trim(); if (turnToken) payload['cf-turnstile-response'] = turnToken;

    const r = await signedPost('/api/chat', payload);
    if(!r.ok) throw new Error(`chat_failed:${r.status}`);
    const j = await r.json();
    const reply = (j.reply || '').trim();
    const confidence = typeof j.confidence === 'number' ? j.confidence : null;
    const shouldEscalate = j.escalate === true || !reply || (confidence !== null && confidence < CONFIDENCE_THRESHOLD);
    if (shouldEscalate){
      escalateWithFallback('low_confidence', msg, thinking, { confidence, upstreamReply: reply });
    } else {
      thinking.textContent = reply;
      recordMessage('assistant', reply, { source:'api', confidence });
    }

  }catch(err){
    escalateWithFallback('network_error', msg, thinking, { error: err?.message || 'unknown_error' });
  }finally{
    state.isSending = false; updateSend();
    window.chattiaTurnstile?.clear(true);
    window.chattiaTurnstile?.resetWidget?.();
  }
});

/* ------------------- Hidden STT wiring ------------------- */
const $ = s=>document.querySelector(s);
const chatInput = $('#chatbot-input');

$('#stt-send')?.addEventListener('click', async ()=>{
  const f = $('#stt-file')?.files?.[0]; if (!f) return;
  if (tTok.dataset.require==='true' || !tTok.value.trim()) return;
  const form = new FormData(); form.append('audio', f); form.append('lang',$('#stt-lang').value||'en'); form.append('prefer',$('#stt-prefer').value||'');
  form.set('cf-turnstile-response', tTok.value);
  const r = await signedFormPost(STT_PATH, form); const d = await r.json();
  if (r.ok && d?.text && chatInput) chatInput.value = d.text;
  tTok.value=''; tTok.dataset.require='true';
  if (window.turnstile && turnstileWidgetId!==null) try{ window.turnstile.reset(turnstileWidgetId); }catch{}
});

let rec, media, chunks=[], recording=false;
$('#mic-btn')?.addEventListener('click', async ()=>{
  if (!recording){
    if (tTok.dataset.require==='true' || !tTok.value.trim()) return;
    try{
      chunks=[]; media=await navigator.mediaDevices.getUserMedia({audio:true});
      rec=new MediaRecorder(media,{mimeType:'audio/webm'}); rec.ondataavailable=e=>{ if(e.data&&e.data.size) chunks.push(e.data); }; rec.start(); recording=true;
    }catch{ return; }
    return;
  }
  rec.stop(); media.getTracks().forEach(t=>t.stop()); recording=false;
  const blob = new Blob(chunks,{type:'audio/webm'}); if (blob.size>8_000_000) return;
  const form = new FormData(); form.append('audio', blob,'clip.webm'); form.append('lang',$('#stt-lang').value||'en'); form.append('prefer',$('#stt-prefer').value||''); form.set('cf-turnstile-response', tTok.value);
  const r = await signedFormPost(STT_PATH, form); const d = await r.json();
  if (r.ok && d?.text && chatInput) chatInput.value = d.text;
  tTok.value=''; tTok.dataset.require='true';
  if (window.turnstile && turnstileWidgetId!==null) try{ window.turnstile.reset(turnstileWidgetId); }catch{}
});
</script>
</body>
</html>
